#!/usr/bin/env babel-node

import fs from 'fs';
import path from 'path';
import glob from 'glob';

var HTMLtoJSX = require('htmltojsx');
var converter = new HTMLtoJSX({
  createClass: false,
});

function renderIcon(className, svgIcon) {
  var output = converter.convert(svgIcon);
  output = output.replace(/<svg /, '<svg {...this.props} ');

  return `import React from 'react';
  // Warning!
  // Autogenerated - do not edit.
  // Edit SVG icons in public/images/icons and run: ./script/generators/render-icons
  export default class ${className} extends React.Component {
    displayName = '${className}'

    static propTypes = {
      className: React.PropTypes.string,
    };

    render() {
      return (
        ${output}
      );
    }
  }
  `.replace(/\n  /g, '\n').replace(/^\s*[\r\n]/gm, '\n').replace(/\t/g, '  ') + '\n';
}

function processSvg() {
  var base = './public/images/icons/';
  glob(base + '*.svg', function(err, icons) {
    if (err) { throw err; }
    console.log('Rendering ' + icons.length + ' icons.');
    icons.forEach(function(icon) {
      var iconData = fs.readFileSync(icon).toString();
      var classBase = icon.replace(/(\-icon)?\.svg/, '').substr(base.length);

      var className = classBase.replace(/-[A-Za-z]/g, function(match) {
        return match.toUpperCase().substr(1);
      });

      className = className.charAt(0).toUpperCase() + className.slice(1);
      var newIcon = renderIcon(className + 'Icon', iconData);

      fs.writeFileSync('./app/icons/svg/' + classBase + '.js', newIcon);
    });
  });
}

function checkSvg() {
  glob('./app/icons/svg/*.js', function(err, icons){
    if (err) { throw err; }

    console.log(`Verifying ${icons.length} icons`);

    icons.forEach(function(icon) {
      try {
        require(path.join(__dirname, '../../', icon.substr(0, icon.length - 3)));
      } catch (e) {
        console.log(`Syntax error found for ${icon}, generated icon invalid.`);
        console.log(e);
      }
    });
  });
}

processSvg();
checkSvg();
